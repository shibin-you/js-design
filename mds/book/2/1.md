# 工厂模式
## 简单工厂模式
先写一个简单的登陆提示
```javascript
// 警告框
var LoginAlert = function(text) {
  this.content = text
}
LoginAlert.prototype.show = function() {
  //显示警告框
}

// 确认框
var LoginConfirm = function(text) {
  this.content = text
}
LoginConfirm.prototype.show = function(text) {
  //显示确认框
}


var passALert = new LoginAlert('密码不正确')
passALert.show()

var loginfailConfirm = new LoginConfirm('用户名不存在，请重新输入或注册')
passALert.show()

```
上面调用有些麻烦，每次都要new,，使用下面方法进行改造
```javascript
var PopFactary = function(name, text) {
  switch (name) {
    case 'alert':
      return new LoginAlert(text);
    case 'confirm':
      return new LoginConfirm(text)
  }
}
```
上面两个类有相同的地方，是可以抽象出来共用的
```javascript
function createPop(type, text) {
  var o = new Object()
  o.content = text
  o.show = function() {

  }
  // 差异方法
  if (type === 'alert') {

  } else if (type === 'confirm') {

  }
  return o
}
```

## 工厂方法模式
工厂方法的本意是将创建对象的工作推迟到子类当中
```javascript
var Factory = function(type, content) {
  if (this instanceof Factory) {
    var s = new this[type](content)
    return s
  } else {
    return new Factory(type, content)
  }
}
// 工厂原型中创建所有类型数据对象的基类
Factory.prototype = {
  Java: function(content) {

  },
  Javascript: function(content) {

  },
  Php: function(content) {

  },
  Python: function(content) {

  }
}

var data = [{
  type: 'Javascript',
  content: 'Javascript哪家强'
}, {
  type: 'Php',
  content: 'Php哪家强'
}, {
  type: 'Java',
  content: 'Java哪家强'
}, {
  type: 'Python',
  content: 'Python哪家强'
}]
for (var i = 0; i < data.length; i++) {
  Factory(data[i].type, data[i].content)
}
```
